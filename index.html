<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="nl">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>AB Statistics Presentation</title>

		<script type="text/javascript" src="jquery/jquery-3.2.1.js"></script>
		<script type="text/javascript" src="d3/d3.js"></script>
		<script type="text/javascript" src="vue/vue.js"></script>
		<script src="bootstrap/js/bootstrap.min.js"></script>
		
		<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
		<link rel="stylesheet" href="reveal/css/reveal.css">
		<link rel="stylesheet" href="reveal/css/theme/white.css">
		<style>
			.text-very-muted {
				color: #BBB;
			}
			.reveal h1 {
				line-height: 0.9em;
				margin-bottom: 0.75em;
			}
			
			h1 span.title-divider {
				overflow: hidden;
				text-align: center;
				display: block;
				font: 90px "Times New Roman";
				font-style: oblique;
				text-transform: lowercase;
				margin: -0.2em auto 0.1em;
			}
			h1 span.title-divider:before,
			h1 span.title-divider:after {
				background-color: #000;
				content: "";
				display: inline-block;
				height: 2px;
				border-radius: 100%;
				position: relative;
				vertical-align: middle;
				width: 50%;
			}
			h1 span.title-divider:before {
				right: 0.5em;
				margin-left: -50%;
			}
			h1 span.title-divider:after {
				left: 0.5em;
				margin-right: -50%;
			}
			.reveal table td.align-center {
				text-align: center;
			}
			.reveal table th.align-center {
				text-align: center;
			}
			.reveal table td.big-font {
				font-size: 90px;
			}
			.reveal table.align-center-except-first-column th:nth-child(1n+2),
			.reveal table.align-center-except-first-column td:nth-child(1n+2) {
				text-align: center;
			}
			.reveal table.align-center-except-first-column td:nth-child(1n+2):empty:after {
				content: "?";
				color: #777;
			}
			.reveal mark {
				background: #d9edf7;
				font-weight: bold;
			}
			.reveal .dice {
				font-size: 20rem;
				line-height: 0.6em;
			}
			.reveal .dice .rolling {
				color: black;
			}
			.reveal .dice .not-six {
				color: #777;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript">
			Vue.component('rubin-model', {
				template: `
					<div class="component">
						<table class="table table-striped align-center-except-first-column">
							<thead>
								<tr>
									<th></th>
									<th>Under A</th>
									<th>Treatment Effect</th>
									<th>Under B</th>
								</tr>
							</thead>
							<tbody>
								<tr v-for="(item, index) in realisation">
									<td>{{ item.name }}</td>
									<td>{{ item.a_show ? item.a : '' }}</td>
									<td>{{ randomize ? '' : (item.b - item.a).toFixed(1)}}</td>
									<td>{{ item.b_show ? item.b : ''}}</td>
								</tr>
								<tr class="text-muted">
									<td>({{ this.sample_name }})</td>
									<td>...</td>
									<td>...</td>
									<td>...</td>
								</tr>
								<tr class="info">
									<td>Average</td>
									<td>{{ this.display_ate ? avg_a.toFixed(1) : '' }}</td>
									<td><b v-if="display_ate">{{ (avg_b - avg_a).toFixed(1) }}</b></td>
									<td>{{ this.display_ate ? avg_b.toFixed(1) : '' }}</td>
								</tr>

							</tbody>
						</table>
						<p><small>[1] Rubin, Donald B. 1974. “Estimating Causal Effects of Treatments in Randomized and Nonrandomized Studies.” Journal of Educational Psychology 66 (5): 688–701.</small></p>
					</div>
				`,
				props: {
					display_ate:	 		{ type: Boolean, default: false },
					randomize:	 			{ type: Boolean, default: false },
					sample_name:	 		{ type: String, default: 'Everyone' },
				},
				data: function () {
					return {
						sample: [
							{ name: 'Alice', a: 0.4, b: 0.9, a_show: 1, b_show: 1 },
							{ name: 'Bob', a: 0.3, b: 0.8, a_show: 1, b_show: 1 },
							{ name: 'Charlie', a: 0.5, b: 1, a_show: 1, b_show: 1 },
							{ name: 'Dave', a: 0.2, b: 0.7, a_show: 1, b_show: 1 },
							{ name: 'Eve', a: 0.4, b: 0.9, a_show: 1, b_show: 1 },
							{ name: 'Frank', a: 0.1, b: 0.6, a_show: 1, b_show: 1 }
						],
						assignment: [],
						repeating: false,
						my_slide: null,
					}
				},
				mounted: function() {
					EventBus.$on('fragmentMethod', params => {
						if (params.id == this.$parent.$el.id) {
							if (params.method == 'rerandomize') {
								this.rerandomize();
							}
							if (params.method == 'toggle_repeat') {
								this.toggle_repeat();
							}
						}
					});
					
					this.rerandomize();
					d3.interval(this.repeat, 250);
				},
				computed: {
					avg_a: function() {
						return	this.realisation
									.map(function(z) { return z.a == 'Yes' ? 1 : z.a == 'No' ? 0 : z.a })
									.reduce(function(a, b) { return a + b; }) / 
								this.realisation
									.map(function(z) { return z.a_show })
									.reduce(function(a, b) { return a + b; });
					},
					avg_b: function() {
						return	this.realisation
									.map(function(z) { return z.b == 'Yes' ? 1 : z.b == 'No' ? 0 : z.b })
									.reduce(function(a, b) { return a + b; }) /
								this.realisation
									.map(function(z) { return z.b_show })
									.reduce(function(a, b) { return a + b; }); 
					},
					realisation: function() { 
						if (!this.randomize) {
							return this.sample;
						} else {
							var c = this.assignment;
							return this.sample.map(
								function(row, index) {
									return { 
										name: row.name,
										a: Math.random() < (row.a * c[index]) ? 'Yes' : 'No',
										a_show: c[index],
										b: Math.random() < (row.b * (1-c[index])) ? 'Yes' : 'No',
										b_show: (1-c[index])
									}
								}
							);
						}
					},
				},
				methods: {
					complete_randomize: function() {
						var n = 6;//this.sample.length;
						var m = Math.ceil(n / 2);
						return Array(m).fill(1).concat(Array(n-m).fill(0)).shuffle();
					},
					rerandomize: function() {
						this.assignment = this.complete_randomize();
					},
					toggle_repeat: function() {
						this.repeating = !this.repeating;
						this.my_slide = Reveal.getIndices().h;
					},
					repeat: function() {
						if (this.repeating && Reveal.getIndices().h == this.my_slide) { this.rerandomize(); }
					},
				}
			});
						
			Vue.component('simulation', {
				template: `
					<div class="container">
						<div class="stretch chart-container"></div>
						<div class="row">
							<table class="table table-striped">
								<thead>
									<tr>
										<th v-if="display_true_effect" class="align-center">simulated effect</th>
										<th v-if="display_observed_effect" class="align-center">average observed effect</th>
										<th v-if="display_type_i" class="align-center">type-I error rate</th>
										<th v-if="display_type_ii" class="align-center">type-II error rate</th>
										<th v-if="display_power" class="align-center">observed power</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td v-if="display_true_effect" class="align-center big-font">{{this.effect}}</td>
										<td v-if="display_observed_effect" class="align-center big-font">{{averages.total ? averages.total.toFixed(3) : "-"}}</td>
										<td v-if="display_type_i" class="align-center big-font">{{type_i_error.toLocaleString('us', {style: 'percent'})}}</td>
										<td v-if="display_type_ii" class="align-center big-font">{{type_ii_error.toLocaleString('us', {style: 'percent'})}}</td>
										<td v-if="display_power" class="align-center big-font">{{power.toLocaleString('us', {style: 'percent'})}}</td>
									</tr>
								</tbody>
							</table>
						</div>
						<p><small class="text-muted"><mark v-if="n != 1000"><var>n</var> = <var>{{n}}</var></mark><span v-if="n == 1000"><var>n</var> = <var>{{n}}</var></span>, <var>base conversion rate</var> = <var>{{cr}}</var>, <var>effect of treatment</var> = <var>{{effect}}</var><span v-if="peek > 1">, <mark>peeking {{peek}} times</mark></span></small></p>
					</div>
				`,
				props: {
					effect: 					{ type: Number, default: 0 },
					n:  						{ type: Number, default: 1000 },
					peek:						{ type: Number, default: 1 },
					display_true_effect: 		{ type: Boolean, default: false },
					display_observed_effect:	{ type: Boolean, default: false },
					display_type_i:				{ type: Boolean, default: false },
					display_type_ii:			{ type: Boolean, default: false },
					display_power: 				{ type: Boolean, default: false },
				},
				data: function () {
					return {
						w: 1140,
						h: 500,
						margin: {top: 10, right: 20, bottom: 20, left: 20},
						bins: 200,
						cr: 0.1,
						bounds: [-0.2,0.2],
						results: { significant: [], insignificant: [], significant_opposite: [] },
						g: '',
						repeating: false,
						my_slide: null,
					}
				},
				computed: {
					width: function() { return +this.w - this.margin.left - this.margin.right },
					height: function() { return +this.h - this.margin.top - this.margin.bottom},
					averages: function() {
						var a = {}, total_sum = 0;
						for (var k in this.results) {
							if (this.results[k].length == 0) { 
								a[k] = NaN;
							} else {
								var sum = this.results[k].reduce(function(a, b) { return a + b; });
								a[k] = sum / this.results[k].length;
								total_sum += sum;
							}
						}
						a.total = total_sum / this.trials;
						return a;
					},
					average_abs_effect: function() {
						return ((this.averages.significant * this.results.significant.length) + 
								(Math.abs(this.averages.significant_opposite||0) * this.results.significant_opposite.length))
								/ (this.results.significant.length + this.results.significant_opposite.length);
					},
					type_i_error: function() {
						if (this.effect != 0) return "-"; // if null is false, type-I error is undefined.
						if (this.trials == 0) return "-";
						if (this.results.significant.length + this.results.significant_opposite.length == 0) return 0;
						return (this.results.significant.length + this.results.significant_opposite.length) / this.trials;
					},
					type_ii_error: function() {
						if (this.effect == 0) return "-"; // if null is true, type-II error is undefined.
						if (this.trials == 0) return "-";
						return 1 - this.power;
					},
					type_m_error: function() {
						return this.average_abs_effect / this.effect;
					},
					type_s_error: function() {
						return this.results.significant_opposite.length / (this.results.significant.length + this.results.significant_opposite.length);
					},
					trials: function() {
						return this.results.significant.length + this.results.significant_opposite.length + this.results.insignificant.length;
					},
					power: function() {
						if (this.effect == 0) return "-"; // if null is true, power is undefined.
						if (this.trials == 0) return "-";
						return (this.results.significant.length + this.results.significant_opposite.length) / this.trials;
					}
				},
				mounted: function() {
					EventBus.$on('fragmentMethod', params => {
						if (params.id == this.$parent.$el.id) {
							if (params.method == 'step') {
								this.step();
							}
							if (params.method == 'toggle_repeat') {
								this.toggle_repeat();
							}
						}
					});
					
					var svg = d3.select(this.$el).select('.chart-container').append("svg")
						.attr("width", '100%')
						.attr("height", '100%')
						.attr('viewBox','0 0 '+this.w+' '+this.h)
						.attr('preserveAspectRatio','xMinYMin');

					this.g = d3.select(this.$el).select("svg").append("g").attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");
					this.update(this.results);
					d3.interval(this.repeat, 100);
				},
				methods: {
					update: function(data) {
						var x = d3.scaleLinear().domain(this.bounds).rangeRound([0, this.width]);
						var histogram = d3.histogram().domain(x.domain()).thresholds(x.ticks(this.bins));
						var b1 = histogram(this.results.significant);
						var b2 = histogram(this.results.significant_opposite);
						var b3 = histogram(this.results.insignificant);
						var b = d3.stack().keys(d3.range(3))(d3.transpose([b1.map(function(d) {return d.length}),b2.map(function(d) {return d.length}),b3.map(function(d) {return d.length})]));
						var y = d3.scaleLinear().domain([0, d3.max(b[2], function(d) { return d[1]; })]).range([this.height, 0]);
						var color = d3.scaleOrdinal().domain(d3.range(3)).range(d3.schemeCategory20);
						var colorsort = [0,0,1];

						var series = this.g.selectAll(".series").data(b);						
						series.enter().append("g")
								.attr("class", "series")
								.attr("fill", function(d, i) { return color(colorsort[i]); })
							.merge(series);

						var rect = series.selectAll("rect").data(function(d) { return d; });
						rect.enter().append("rect")
								.attr("x", 1)
								.attr("width", x(b1[0].x1) - x(b1[0].x0))
								.attr("transform", function(d, i) { return "translate(" + x(b1[i].x0) + "," + y(d[0]) + ")"; })
								.attr("height", 0)
							.merge(rect)
								.transition().duration(100)
									.attr("transform", function(d, i) { return "translate(" + x(b1[i].x0) + "," + y(d[1]) + ")"; })
									.attr("height", function(d) { return y(0) - y(d[1]-d[0]); });
						
						this.g.selectAll(".axis").remove();
						this.g.append("g")
							.attr("class", "axis axis--x")
							.attr("transform", "translate(0," + this.height + ")")
							.call(d3.axisBottom(x));
					},
					step: function() {
						for (var j = 0; j < Math.min(100,10**(""+(this.trials)).length/10); ++j) {
							var base_n  = 0; var var_n = 0; var base_c = 0; var var_c = 0;
							for (var k = 0; k < this.peek; ++k) {
								var n_add = Math.ceil(this.n / this.peek);
								
								var base_n_add = this.rbinom(n_add, 0.5);
								var var_n_add = n_add - base_n_add;

								base_n += base_n_add;
								var_n += var_n_add;
							
								base_c += this.rbinom(base_n_add, this.cr);
								var_c += this.rbinom(var_n_add, (this.cr + this.effect));
							
								effect = (var_c/var_n) - (base_c/base_n);
								gval = calculate_g_test([[base_n - base_c, base_c], [var_n - var_c, var_c]]);

								if (gval >= 3.841459) {
									break;
								}
							}

							if (gval >= 3.841459) {
								if (effect > 0) {
									this.results.significant.push(effect);
								} else {
									this.results.significant_opposite.push(effect);
								}
							} else {
								this.results.insignificant.push(effect);
							}
						}
					},
					toggle_repeat: function() {
						this.repeating = !this.repeating;
						this.my_slide = Reveal.getIndices().h;
					},
					repeat: function() {
						if (this.repeating && Reveal.getIndices().h == this.my_slide) { this.step(); }
					},
					rbinom: function(n, p) {
						var b = 0;
						for (var i = 0; i < n; ++i) { if (Math.random() < p) ++b; };
						return b;
					},
				},
				watch: {
					trials: function(val) { this.update(val) }
				}
			});
			
			// This takes an array of arrays of any size, and calculates
			// the raw g-test value.  It assumes a square matrix of arguments.
			function calculate_g_test (data) {
				var rows = data.length;
				var columns = data[0].length;

				// Initialize our subtotals
				var row_totals = [];
				for (var i = 0; i < rows; i++) {
					row_totals[i] = 0;
				}

				var column_totals = [];
				for (var j = 0; j < columns; j++) {
					column_totals[j] = 0;
				}

				var total = 0;

				// First we calculate the totals for the row and the column
				for (var i = 0; i < rows; i++) {
					for (var j = 0; j < columns; j++) {
						var entry = data[i][j] - 0;  // - 0 ensures numeric
						row_totals[i]    += entry;
						column_totals[j] += entry;
						total            += entry;
					}
				}

				// Now we calculate the g-test contribution from each entry.
				var g_test = 0;;
				for (var i = 0; i < rows; i++) {
					for (var j = 0; j < columns; j++) {
						var expected = row_totals[i] * column_totals[j] / total;
						var seen     = data[i][j];

						g_test      += 2 * seen * Math.log( seen / expected );
					}
				}

				return g_test;
			};
			
			// Shuffle an array. 'Borrowed' from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
			Array.prototype.shuffle = function() {
				var currentIndex = this.length, temporaryValue, randomIndex;

				// While there remain elements to shuffle...
				while (0 !== currentIndex) {

				// Pick a remaining element...
					randomIndex = Math.floor(Math.random() * currentIndex);
					currentIndex -= 1;

					// And swap it with the current element.
					temporaryValue = this[currentIndex];
					this[currentIndex] = this[randomIndex];
					this[randomIndex] = temporaryValue;
				}

				return this;
			}
		</script>

		<div class="reveal">
			<div class="slides">
				<section id="title">
					<h1>Design <span class="title-divider">of</span> experiments</h1>
					<p>Statistical foundations for causal inference</p>
					<br />
					<p>
						<small>
							Lukas Vermeer <span class="text-muted">is</span> Senior Product Owner <span class="text-muted">for</span> Experimentation <span class="text-muted">at</span> Booking.com
						</small>
					</p>
					<p>
						<small>							
							<a href="http://twitter.com/lukasvermeer" target="_blank">@lukasvermeer</a> &mdash; <a href="http://lukasvermeer.github.io/ab-stats" target="_blank">lukasvermeer.github.io/ab-stats</a>
						</small>
					</p>
				</section>
				
				<section id="causal-inference">
					<span class="text-muted">Making good decisions requires</span>
					<h2>causal inference</h2>
					<p>
						<span class="fragment">Umbrellas often appear just before it pours,</span>
						<span class="fragment">but banning them will not stop the rain;</span>
						<span class="fragment">it will just make everyone <mark>more wet</mark></span>
					</p>

					<aside class="notes" data-markdown>
						- We want gather evidence for a causal link between a change and behaviour
							- “By switching to B, we will cause more people to click ads or buy our product!”
						- Correlation is not sufficient for supporting decision making
							- Direction of effect is as important as showing there is a relation at all
					</aside>
				</section>
								
				<section id="app-rubin-full">
					<h3>Rubin causal model <small>(what we want to know)</small></h3>
					<rubin-model display_ate></rubin-model>
				</section>

				<section id="fundamental-problem">
					<span class="text-muted">The fundamental problem of</span>
					<h2>causal inference</h2>
					<ol>
						<li class="fragment">We cannot sample the entire <mark>population</mark></li>
						<li class="fragment">We cannot expose units to both treatments <mark>exclusively</mark></li>
						<li class="fragment">We cannot directly observe <mark>underlying</mark> probabilities</li>
					</ol>
					
					<aside class="notes" data-markdown>
						- Other potential, but unquantifiable, sources of uncertainty also exist
							- The population may change
							- The treatment may change
							- The effect may change
						- Stability of these other factors is (often implicitly) assumed
					</aside>
				</section>

				<section id="app-rubin-fpci">
					<h3>Rubin causal model <small>(what we can measure)</small></h3>
					<rubin-model sample_name="Sample" randomize></rubin-model>
					<span class="fragment" data-method="rerandomize"><small class="text-very-muted"><i class="glyphicon glyphicon-step-forward"></i></small></span>
					<span class="fragment" data-method="toggle_repeat" trigger-hidden><small class="text-very-muted"><i class="glyphicon glyphicon-forward"></i></small></span>
				</section>

				<section id="two-questions">
					<span class="text-muted">We will try to answer two</span>
					<h2>key questions</h2>
					<ol>
						<li class="fragment"><mark>Is there</mark> any causal effect?</li>
						<li class="fragment">What is the <mark>size</mark> of the causal effect?</li>
					</ol>

					<aside class="notes" data-markdown>
						- Sometimes we will get “unlucky” in our randomisation
							- We might randomly put all the men in one group and all the women in the other 
							- We can estimate the likelihood of getting a particular result by chance using a test statistic
						- Every randomisation will likely give us a slightly different result
							- Every time the experiment is repeated with new randomisation, the averages will be different
							- We can quantify an expected range of results using a confidence interval
					</aside>
				</section>
				
				<section id="expectation">
					<span class="text-muted">Our answers will be correct</span>
					<h2>in expectation</h2>
					<p>
						<span class="fragment">If we show A and B to random samples of the population,</span>
						<span class="fragment">then the fraction of wins in both groups converges to the true underlying means,</span>
						<span class="fragment">and the difference between the means converges to the <mark>average treatment effect</mark></span>
					</p>

					<aside class="notes" data-markdown>
						- In expectation, the average of a random sample will approximate true mean of the population
						- In expectation, the fraction of wins will approximate underlying probability
							- We do not need to observe the probabilities directly if we have the outcomes for individuals
						- In expectation, the difference between averages will give us the ATE
							- We do not need to measure the treatment effects of each individual participant
					</aside>
				</section>

				<section id="app-rubin-ate">
					<h3>Rubin causal model <small>(what randomisation gives us)</small></h3>
					<rubin-model sample_name="Sample" randomize display_ate></rubin-model>
					<span class="fragment" data-method="rerandomize"><small class="text-very-muted"><i class="glyphicon glyphicon-step-forward"></i></small></span>
					<span class="fragment" data-method="toggle_repeat" trigger-hidden><small class="text-very-muted"><i class="glyphicon glyphicon-forward"></i></small></span>
				</section>
				
				<section id="app-expectation">
					<simulation v-bind:effect="0.1" display_true_effect display_observed_effect></simulation>
					<span class="fragment" data-method="step"><small class="text-very-muted"><i class="glyphicon glyphicon-step-forward"></i></small></span>
					<span class="fragment" data-method="step"><small class="text-very-muted"><i class="glyphicon glyphicon-step-forward"></i></small></span>
					<span class="fragment" data-method="step"><small class="text-very-muted"><i class="glyphicon glyphicon-step-forward"></i></small></span>
					<span class="fragment" data-method="toggle_repeat" trigger-hidden><small class="text-very-muted"><i class="glyphicon glyphicon-forward"></i></small></span>
				</section>

				<!--
				<section id="confidence-intervals">
					<span class="text-muted">estimates are expected to fall</span>
					<h2>within a range</h2>
					
					<p>
						The following statement is technically incorrect, but I'm not sure how to explain it better. :-/
					</p>
					<p>
						<span class="fragment">Every randomisation will assign treatment differently,</span>
						<span class="fragment">so we can expect group averages to vary as well,</span>
						<span class="fragment">but we can quantify the expected range of variation using a <mark>confidence interval</mark></span>
					</p>

					<aside class="notes" data-markdown>
						- Every randomisation will assign treatment differently
							- If we were to repeat the same experiment, assignment would change
							- As a result, we would expect group averages to vary as well
						- We can quantify the expected range of variation using a confidence interval
							- We can expect results to be between X and Y 95% of the times we repeat the experiment
					</aside>
				</section>
				-->

				<section id="randomisation">
					<span class="text-muted">Randomisation ensures only three things can</span>
					<h2>explain a difference</h2>
					
					<ol>
						<li class="fragment"><mark>Causation</mark> resulted in people behaving differently when treatment was applied</li>
						<li class="fragment"><mark>Pure chance</mark> resulted in a difference between the two groups unrelated to the treatment</li>
						<li class="fragment"><mark>Measurement error</mark> resulted in an unintended difference in results unrelated to user behaviour</li>
					</ol>
				</section>

				<section id="null-hypothesis">
					<span class="text-muted">We want to reject the</span>
					<h2>null hypothesis</h2>
					<p>
						<span class="fragment">Any difference we see could be the result of chance, </span>
						<span class="fragment">but if we could reasonably rule out chance, </span>
						<span class="fragment">we might consider this to be evidence for the <mark>alternative hypothesis</mark>.</span>
					</p>
					
					<aside class="notes" data-markdown>
						- We will want to refute the hypothesis that there is no effect
							- We will consider rejection of the “null hypothesis” as evidence for the “alternative hypothesis”
					</aside>
				</section>

				<section id="p-value">
					<span class="text-muted">We compute a</span>
					<h2>p-value</h2>
					<p>
						<span class="fragment">Assuming there is no effect, </span>
						<span class="fragment">the p-value is the probability of seeing a particular result or more extreme by chance.</span>
					</p>
					<p>
						<span class="fragment"><b>How unlikely is this result <mark>assuming the null is true</mark>?</b></span>
					</p>
				</section>

				<section id="loaded-die">
					<span class="text-muted">Is this die</span>
					<h2>Fair?</h2>
					<p class="dice">
						<span class="fragment">&#x2685</span>
						<span class="fragment">&#x2685</span>
						<span class="fragment">&#x2685</span>
					</p>
					<p>
						<span class="fragment">p = 0.00462962</span>
						</br>
						<span class="fragment text-muted"><small>(Not fair; I cheated)</small></span>
					</p>

					<aside class="notes" data-markdown>
						- We might argue that small odds support accepting an alternative explanation
							- For instance that the die is loaded, of that I can influence the result through telepathy
					</aside>
				</section>

				<section id="significance-threshold">
					<span class="text-muted">We need to pick a</span>
					<h2>threshold</h2>
					<p>
						<span class="fragment">One swallow does not a summer make, nor one fine day,</span>
						<span class="fragment">but how many swallows do we count before we pack away our umbrellas?</span>
					</p>
					<p>
						<span class="fragment"><b>Scientific standard for significance:</b> <mark>p < 0.05</mark></span>
					</p>
					
					<aside class="notes" data-markdown>
						- Sometimes we will get “unlucky” in our randomisation
							- We will have to decide at which point we will reject the idea that our result could be chance
							- At this point, we will accept the alternative hypothesis and argue there is a causal effect
					</aside>
				</section>

				<section id="misinterpreted-p-value">
					<span class="text-muted">p-values are often<small>[2]</small></span>
					<h2>misinterpreted</h2>
					
					<span class="fragment">Some examples of <mark>incorrect</mark> interpretations</span>
					<ol>
						<li class="fragment">p = .05 means the null hypothesis has only a 5% chance of being true</li>
						<li class="fragment">A non-significant difference (e.g. p > .05) means there is no difference between groups</li>
						<li class="fragment">p = .05 means that we have observed data that would occur only 5% of the time under the null</li>
						<!-- <li class="fragment">p = .05 means that if you reject the null, the probability of a type I error (false positive) is 5%</li> -->
					</ol>
					
					<p><small>[2] Goodman, Steve 2008. “A dirty dozen: twelve P-value misconceptions.” Seminars in Hematology, 45 (2008), pp. 135-140.</small></p>
					
					<aside class="notes" data-markdown>
						- p-value gives us Prob(X >= x | H0), whereas what we want is Prob(H0 | X = x)
						- Here are some incorrect statements from Steve Goodman’s A Dirty Dozen[2]
					</aside>
				</section>

				<section id="errors">
					<span class="text-muted">Two types of</span>
					<h2>errors</h2>
					
					<ol>
						<li class="fragment"><mark>Type-I</mark> is the incorrect rejection of a true null hypothesis; <span class="fragment">we cried wolf when there was none</span></li>
						<li class="fragment"><mark>Type-II</mark> is the failure to reject a false null hypothesis; <span class="fragment">we failed to detect a real effect</span></li>
					</ol>
					
					<aside class="notes" data-markdown>
						- The result might simply not be that unlikely when assuming the null is true
					</aside>
				</section>

				<section id="app-type-i">
					<simulation v-bind:effect="0.0" display_true_effect display_type_i></simulation>
					<span class="fragment" data-method="step"><small class="text-very-muted"><i class="glyphicon glyphicon-step-forward"></i></small></span>
					<span class="fragment" data-method="toggle_repeat" trigger-hidden><small class="text-very-muted"><i class="glyphicon glyphicon-forward"></i></small></span>
				</section>

				<section id="app-type-ii">
					<simulation v-bind:effect="0.05" display_true_effect display_type_ii></simulation>
					<span class="fragment" data-method="step"><small class="text-very-muted"><i class="glyphicon glyphicon-step-forward"></i></small></span>
					<span class="fragment" data-method="toggle_repeat" trigger-hidden><small class="text-very-muted"><i class="glyphicon glyphicon-forward"></i></small></span>
				</section>

				<section id="power">
					<span class="text-muted">The importance of</span>
					<h2>Statistical power</h2>
					
					<p>
						<span class="fragment">Statistical power is the probability that the test <mark>correctly rejects</mark> the null hypothesis when the alternative hypothesis is true</span>
					</p>
					<p>
						<span class="fragment"><b>Two main things affect statistical power:</b></span>
						<ul>
							<li class="fragment">Sample size <span class="text-muted">(more is better)</span></li>
							<li class="fragment">Effect size <span class="text-muted">(more is better)</span></li>
						</ul>
					</p>
					
					<aside class="notes" data-markdown>
						- Effect size is unknown but assumed fixed
						- Sample size may be increased is low power is expected
					</aside>
				</section>

				<section id="app-type-ii-2">
					<simulation v-bind:effect="0.05" v-bind:n="2000" display_type_ii display_power></simulation>
					<span class="fragment" data-method="toggle_repeat" trigger-hidden><small class="text-very-muted"><i class="glyphicon glyphicon-forward"></i></small></span>
				</section>

				<section id="app-type-ii-3">
					<simulation v-bind:effect="0.05" v-bind:n="4000" display_type_ii display_power></simulation>
					<span class="fragment" data-method="toggle_repeat" trigger-hidden><small class="text-very-muted"><i class="glyphicon glyphicon-forward"></i></small></span>
				</section>

				<section id="protocol">
					<span class="text-muted">The importance of sticking to</span>
					<h2>Protocol</h2>
					
					<p>
						<span class="fragment">The methods described assume strict adherence to protocol;</span>
						<span class="fragment">violations of protocol such as <mark>peeking</mark> and <mark>multiple testing</mark> increase the type-I error rate</span>
					</p>
				</section>

				<section id="app-multiple-testing">
					<simulation v-bind:effect="0.00" v-bind:peek="2" display_true_effect display_type_i></simulation>
					<span class="fragment" data-method="toggle_repeat" trigger-hidden><small class="text-very-muted"><i class="glyphicon glyphicon-forward"></i></small></span>
				</section>

				<section id="app-multiple-testing-2">
					<simulation v-bind:effect="0.00" v-bind:peek="100" display_true_effect display_type_i></simulation>
					<span class="fragment" data-method="toggle_repeat" trigger-hidden><small class="text-very-muted"><i class="glyphicon glyphicon-forward"></i></small></span>
				</section>

				<section id="adaptive-methods">
					<span class="text-muted">The importance of violating</span>
					<h2>Protocol</h2>
					
					<p>
						<span class="fragment">More flexible protocols may be desirable</span>
						<ul>
							<li class="fragment"><mark>early stopping rules</mark> to mitigate damage</li>
							<li class="fragment"><mark>early shipping</mark> to minimize opportunity cost</li>
							<li class="fragment"><mark>multiple variants</mark> to test several alternatives</li>
							<li class="fragment"><mark>multiple metrics</mark> to guard business KPIs</li>
						</ul>
					</p>
					<div class="fragment">
						<p>All these are possible<small>[4]</small>, but require protocol adjustments</p>
						<p><small>[4] Alex Deng, Tianxi Li, Yu Guo 2014 “Statistical Inference in Two-Stage Online Controlled Experiments with Treatment Selection and Validation” WWW '14. 609–618.</small></p>
					</div>
				</section>

				<section id="end">
					<h1>Design <span class="title-divider">of</span> experiments</h1>
					<p>Statistical foundations for causal inference</p>
					<br />
					<p>
						<small>
							Lukas Vermeer <span class="text-muted">is</span> Senior Product Owner <span class="text-muted">for</span> Experimentation <span class="text-muted">at</span> Booking.com
						</small>
					</p>
					<p>
						<small>							
							<a href="http://twitter.com/lukasvermeer" target="_blank">@lukasvermeer</a> &mdash; <a href="http://lukasvermeer.github.io/ab-stats" target="_blank">lukasvermeer.github.io/ab-stats</a>
						</small>
					</p>
				</section>
				
				<section id="references">
					<h2>References</h2>
					
					<ol>
						<li><small>Rubin, Donald B. 1974. “Estimating Causal Effects of Treatments in Randomized and Nonrandomized Studies.” Journal of Educational Psychology 66 (5): 688–701. (<a href="http://dx.doi.org/10.1037/h0037350" target="_blank">link</a>)</small></li>
						<li><small>Goodman, Steve 2008. “A dirty dozen: twelve P-value misconceptions.” Seminars in Hematology, 45 (2008), pp. 135-140. (<a href="https://www.researchgate.net/publication/5272766_A_Dirty_Dozen_Twelve_P-Value_Misconceptions" target="_blank">link</a>)</small></li>
						<li><small>Kohavi, R., Longbotham, R., Sommerfield, D. et al. 2009 “Controlled experiments on the web: survey and practical guide” Data Min Knowl Disc (2009) 18: 140. (<a href="http://bit.ly/expSurvey" target="_blank">link</a>)</small></li>
						<li><small>Alex Deng, Tianxi Li, Yu Guo 2014 “Statistical Inference in Two-Stage Online Controlled Experiments with Treatment Selection and Validation” WWW '14. 609–618.(<a href="http://www.exp-platform.com/Documents/p609-deng.pdf" target="_blank">link</a>)</small></li>
					</ol>
				</section>
			</div>
		</div>
		
		<script src="reveal/lib/js/head.min.js"></script>		
		<script src="reveal/js/reveal.js"></script>
		<script type="text/javascript">
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				width: 1140,
				height: 960,
				margin: 0.05,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal/plugin/zoom-js/zoom.js', async: true },
					{ src: 'reveal/plugin/notes/notes.js', async: true }
				]
			});
			
			const EventBus = new Vue();
			
			new Vue({ el: '#app-rubin-full' });
			new Vue({ el: '#app-rubin-fpci' });
			new Vue({ el: '#app-rubin-ate' });
			
			new Vue({ el: '#app-expectation' });
			new Vue({ el: '#app-type-i' });
			new Vue({ el: '#app-type-ii' });
			new Vue({ el: '#app-type-ii-2' });
			new Vue({ el: '#app-type-ii-3' });
			new Vue({ el: '#app-multiple-testing' });
			new Vue({ el: '#app-multiple-testing-2' });
			
			Reveal.addEventListener( 'fragmentshown', function( event ) {
				if (event.fragment.hasAttribute('data-method')) {
					EventBus.$emit('fragmentMethod', { id: event.fragment.parentNode.id, method: event.fragment.getAttribute('data-method')});
				}
			} );
			Reveal.addEventListener( 'fragmenthidden', function( event ) {
				if (event.fragment.hasAttribute('data-method') && event.fragment.hasAttribute('trigger-hidden')) {
					EventBus.$emit('fragmentMethod', { id: event.fragment.parentNode.id, method: event.fragment.getAttribute('data-method')});
				}
			} );
		</script>
	</body>
</html>